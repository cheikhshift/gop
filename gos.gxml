<?xml version="1.0" encoding="UTF-8"?>
<gos>
	<!--Stating the deployment type GoS should compile -->
	<!-- Curent valid types are webapp,shell and bind -->
	<!-- Shell = cli, sort of a GoS(Ghost) in the Shell -->
	<deploy>package</deploy>
	<port>8080</port>
	<package>passport</package>
	<not_found>/your-404-page</not_found>
	<error>/your-500-page</error>
	<!-- Using import within different tags will have different results -->
	<!-- We going to make the goPkg Mongo Db Driver available to our application -->
	<!-- Using <import/> within the <go/> tag is similar to using the import call within a .go file -->
	<!-- To be less dramating, GoS will skip packages that it has already imported -->
	<import src="github.com/cheikhshift/db/gos.gxml"/>
	<!-- Go File output name -->
	<import src="github.com/jtblin/go-ldap-client"/>
	<import src="github.com/cheikhshift/gop"/>
	<output>server_out.go</output>
	<!-- exported session fields available to Session -->
	<main>
	/* GOLANG SCOPE */
		

	</main>
	<!-- Declare global variables -->
	<!-- Contains interfaces and structs
	 that will be used by the GoS application -->
	<header> 
			<!-- remember to Jumpline when stating methods or different struct attributes, it is vital for our parser \n trick -->


		<!-- Required for Gos To compile \|/-->
	    <struct name="UserSpace">
				/* Property Type */
		</struct>
		<object name="UserSpaceInterface" struct="UserSpace">
		   
		</object>
	</header>
	<methods>
		<!-- Vars are defined as usual except within the var attribute for example :  -->
		<!-- If there is a basic go function : func hackfmt(data string, data2 string) -->
		<!-- the attribute names would be called as such var="data string,data2 string" -->
		<!-- Similar to a go function decleration-->
		<!--  if a method matches the criteria for an  interface it will be used as an interface method -->
		<!-- To prevent that use the autoface attribute and set it to "false" By default it is true -->
		<!-- Use the keep-local="true" attribute to limit a method within a Go file -->	
		<!-- Sometimes your method will return data  -->
		<!-- And to do so we will need to add a return var list by using the return attribute  -->
		<!-- Sometimes the autointerface will reuse the wrong the function, or your interface methods need a bit more distinction -->
		<!-- Vis a  vis which object types are used in generating these mutating methods -->
		<!--Use the limit attribute to narrow down the applicable structs for this method -->
		<!-- Use the object attribute to determine the name of the local variable name to be mutated within the function. By default GoS will assume object is the variable name  -->
	</methods>

	<templates>
 		<!-- Template libraries are useful for expediting page creation and reuse common website elements within this GoS application -->

 		<!-- *Notice that special braces are used to initialize the parameters of the struct '&{' and '}&' -->
 		
 		<!-- <template name="Bootstrap_alert" tmpl="bootstrap/alert" struct="Bootstrap_alert" /> -->
 		
	</templates>
	<endpoints>
      <!-- Depending on your build type the usage of this tag will vary. -->
      <!-- For WebServers it will override any request for a given path and run the specified method. No vars or return types are needed for  -->
      <!-- methods linked to an API call, please keep in mind that you may use w for http.ResponseWriter and r for http.Request . Additional available function variables is params and session. If a function is api listed it will not be used anywhere else.-->
      <!-- <end /> is the endpoint tag and has the variables path,method, -->
      <!-- Happy trails!!! -->
      <!-- <end path="/index/api"  type="POST" >
      	varr := "data"
      	fmt.Println(varr)
      	//response is the string variable sent -> mResponse()
      	response = varr
      </end> -->
      <end path="/" type="f" >
      		if gop.Contains( gop.Zones , r.URL.Path) {
      			//get user
      			user,err := gop.GetUser(session)

      			if err != nil {
      				http.Redirect(w,r,UPage,302)
      				return true
      			}

      			if !gop.Contains(user.Scopes, r.URL.Path) {
      				http.Redirect(w,r,UPage,302)
      				return true
      			}
      			//procceed
      		}
      </end>

   <!--   <end path="/login" type="POST" >
      	
      	succ, err := gop.Login(r.FormValue("username") ,
      		r.FormValue("password") ,
      		session )

      	if err != nil {
      		response = err.Error()
      	} else {
      			//redirect or return user
      			user := gop.GetUser(session)
      			//save in case you're redirecting
      			session.Save(r,w)

      	}

      </end>

   <end path="/join" type="POST" >
      	
      succ, err := gop.Join(r.FormValue("username") ,
      		r.FormValue("password") , 
      		r.FormValue("email") ,
      		session )

      	if err != nil {
      		response = err.Error()
      	} else {
      			//redirect or return user
      			user := gop.GetUser(session)
      			//save in case you're redirecting
      			session.Save(r,w)

      	}

   </end> -->

	</endpoints>
</gos>
